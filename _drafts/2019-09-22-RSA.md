---
layout: post
title:  "RSA 암호화"
date:   2019-09-19 07:07:07 +0900
categories: rsa key
---

유클리드의 발견:
모든 숫자는 2개의 범주로 나뉜다.
1. 소수의 반복으로 나뉠 수 있는 합성수
2. 소수

**모든 수는 소수의 반복으로 나뉠 수 있고 그 소수의 집합이 소인수이며, 유클리드는 소인수들을 특정한 횟수만큼 곱해서 원래의 숫자로 만들 수 있다고 인식함**

**모든 수는 오직 하나의 소인수 분해 조합으로 이루어져 있다**

**위의 2가지가 유클리가 발견한 연산의 기본정리의 근원임** 




1976년, 마틴 헬만과 휘트필드 디피가 고안한 암호화 방식이 공개키 암호화의 시초임.
이 암호화 방식이 기반으로 하는 2가지 사실을 '색깔'로 예를 들면,
1. 2가지 색을 섞어서 제 3의 색을 만들기는 매우 쉽다.
2. 제 3의 색을 되돌려서 원래의 2가지 색을 찾기는 매우 어렵다.
=> 이렇게 한 방향은 매우 쉽지만 반대방향은 매우 어려운 것이 'one-way function'이다.

로직을 설명하자면 이렇다.
1. A, B가 서로 비밀의 색을 공유하기로 했는데 C가 둘의 대화를 엿듣고 있다.
2. A, B가 공개적으로 '노란'색을 공유. 엿듣던 C도 '노란'색을 알고 있다.(public key)
3. A와 B는 각각의 비밀색(private key)을 노란색과 섞어서 AC, BC 색을 만들고 서로 교환한다. 엿듣던 C는 노랑, AC, BC 색을 알게 된다.
4. A와 B는 각자의 비밀색을 전달받은 BC, AC에 섞어서 공유한 비밀색을 알게 된다(같은 색이 나올 수 밖에 없음)
5. 엿듣던 C가 공유한 비밀색을 알기 위해서는 A나 B의 비밀색 중 하나를 알아야 한다.




이 과정을 '수의 연산'에 대입하기 위해서 '모듈러 연산'이 필요하다.
'모듈러 연산'을 위해서 소수를 사용하게 된다.

```3(소수)^n mod 17(소수) = x```

이 때, 3의 특수한 속성을 알 수 있는데 제너레이터(g)를 3으로 하고 지수 n을 올리면 모듈러 연산의 해가 획일적으로 0~16 사이에 분포하게 됨.

```3^(?) mod 17 = 12```

가 주어졌을 때 (?)를 아는 것은 어렵다. 물론 3, 17과 같은 수로는 매우 쉽겠지만 17이 수백개의 길이를 가진 '소수'라면 사실상 불가능에 가까움.

그래서 'one way function'이 강력하게 작동하기 위해서는 reverse 하는 과정이 얼마나 어렵냐에 달려 있음.

그럼 이제 A, B가 비밀색을 공유하는 과정을 모듈러 연산으로 치환해보자.
1. A, B가 특정한 수를 공유하기로 했는데 C가 둘의 대화를 엿듣고 있다.
2. A, B가 공개적으로 '3 mod 17'을 공유. 엿듣던 C도 알게 된다.(g=3, mod=17)
3. A는 자신만의 비밀 수인 15를 공개한 식에 대입해서 6이라는 결과를 B에게 전달한다.(매우 쉬운 과정)
4. B도 자신만의 비밀 수인 13을 대입해서 12라는 결과를 A에게 전달한다.
5. C는 '3 mod 17'과 6, 12를 알게 된다.
6. A는 B에게 받은 12를 제너레이터로 '12^15 mod 17 = 10'이라는 결과를 알게 되고, B 또한 A에게 받은 6을 제너레이터로 '6^13 mod 17 = 10' 이라는 결과를 알게 된다.
5. 엿듣던 C가 공유한 수를 알기 위해서는 A나 B의 비밀 수 중 하나를 알아야 한다.

6번 과정이 같은 결과가 나오는 이유는 똑같은 색깔을 3개 섞어서 같은 결과가 나온 것처럼 동일한 계산 과정이 있었기 때문임.
 
1. 12^15 mod 17 = 6^13 mod 17
2. 12 = 3^13 mod 17, 6 = 3^15 mod 17임.
3. 치환하면 3^13^15 mod 17 = 3^15^13 mod 17 로 동일한 계산과정이 나옴.




암호술은 원래 대칭적 암호표에 기초를 두고 사용되어 옴. 그런데 만약에 내가 수천명의 사람과 암호통신을 하려면 사람마다 특정 암호표를 새로 생성해야 함(암호표를 수천명과 공유할 수는 없기 때문에) 이걸 해결하기 위해 영국 수학자 제임스 엘리스는 간단하고 기발한 방법을 제안함. 바로 잠그는 것과 푸는 과정을 '반대로' 하는 것.
 
내가 통신하고자 하는 모든 사람에게 암호화를 하기 위한 공개된 암호표를 제공하고(public key), 암호화된 내용을 받으면 나만 갖고 있는 비밀 암호표(private key)로 해독하는 것. 이게 비대칭 암호화, 공개키 암호화의 기본 개념이고 이 개념을 현재 컴퓨터 보안에 RSA라는 대표적인 방식으로 사용함.





클리포드 콕스는 매우 큰 수의 소인수분해가 어렵다는 점을 이용해서 공개키 암호화 방식의 개념을 만들었는데,
N의 소인수분해(복호화)를 알아내기 위한 함수가 필요했고 그래서 사용한게 오일러의 파이 함수.
이 오일러 함수를 trapdoor 라는 개념으로 설정하고 사용함.

오일러 파이(φ) 함수는 임의의 값 N에 대해서 N과 서로소인 정수의 개수를 구하는 함수임.

φ(8) = (1, 3, 5, 7) = 4
φ(7) = (1, 2, 3, 4, 5, 6) = 6

만약 N이 소수라면 N과 서로소인 정수는 N-1개가 됨. 그리고 N이 소수 p, q의 곱이라면 φ(N) = φ(p) * φ(q)가 됨.
따라서 N이 소수 p, q의 곱이라면 φ(N) = (p-1) * (q-1)이 됨.
이 개념과 '모듈러 연산'을 연결해서 복호화 방식을 만듬.

1. 비밀키를 만들고자 하는 Mike가 있다.
2. Mike는 자릿수가 비슷한 두 개의 소수 p, q을 만든다.
3. p * q로 N을 만든다. 동시에 φ(N)의 값도 알 수 있다.
4. 1 < e < φ(N)이고 φ(N)과 서로소이며 홀수이며 작은 지수인 e를 정한다.
5. 지수 d를 계산한다(d=k*φ(N)+1/e)
6. N과 e를 제외한 모든 수(p, q, φ(N), d)를 trapdoor에 숨긴다.
7. James는 Mike에게 비밀숫자 m을 건네기 위해서 공개된 수인 N, e를 모듈러 함수에 적용하여 c(=m^e mod N)를 만든다.
8. 만든 c를 Mike에게 전달한다.
9. Mike는 trapdoor에서 d를 꺼내 c^d mod N을 계산한다.
10. 계산한 결과는 James가 보낸 m과 같다.

소인수분해를 알아야 복호화가 쉽다는 개념에서 출발한 이 개념은 클리포드 콕스가 발표하자마자 기밀로 분류되었지만
MIT의 Ron Rivest, Adi Shamir, Leonard Adleman이 재발견하여 그들의 성을 따서 RSA라는 이름으로 암호화 기법이 만들어졌다.

소인수분해의 난이도에 따라 암호화의 방어력이 결정된다.

 
 
 
 
컴퓨터과학에서는 대표적으로 AES(Advanced Encryption Standard)가 사용되어져 옴.

[1]: https://ko.khanacademy.org/computing/computer-science/cryptography/modern-crypt/v/the-fundamental-theorem-of-arithmetic-1
[2]: https://bpsecblog.wordpress.com/2016/12/05/amalmot_6/
