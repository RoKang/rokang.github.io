<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-17T15:54:10+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">강뱅</title><subtitle>cooool</subtitle><entry><title type="html">CustomView를 만드는 더 나은 방법</title><link href="http://localhost:4000/ios-custom-view/" rel="alternate" type="text/html" title="CustomView를 만드는 더 나은 방법" /><published>2020-04-22T00:00:00+09:00</published><updated>2020-04-22T00:00:00+09:00</updated><id>http://localhost:4000/ios-custom-view</id><content type="html" xml:base="http://localhost:4000/ios-custom-view/">&lt;p&gt;CustomView는 같은 UI를 가지는 View들을 하나의 공통된 View로 묶어 &lt;strong&gt;재사용&lt;/strong&gt;하기 위해 만듭니다. 중복을 줄여주는 장점 때문에 저는 되도록 만들어 쓰는 편입니다. CustomView를 만드는 방법은 쉽게 찾아볼 수 있고 2가지로 나뉘더군요. 그 2개의 방법의 차이점을 파악하고 어떤 방법이 더 나은지를 확인하고자 합니다.&lt;/p&gt;

&lt;h2 id=&quot;customview를-만드는-2가지-방법&quot;&gt;CustomView를 만드는 2가지 방법&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;IB에서 File’s Owner의 CustomView 클래스를 설정하고 Outlet을 연결한다.&lt;/li&gt;
    &lt;li&gt;IB에서 View object의 CustomView 클래스를 설정하고 Outlet을 연결한다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;두 개의 방법은 IB에서의 차이점도 있지만 뷰를 초기화하는 코드에도 차이점이 있습니다.
(지금부터는 편의상 두 가지 방법을 1번, 2번으로 쓰겠습니다)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;1번 초기화 방법&lt;/strong&gt;&lt;noscript&gt;&amp;lt;pre&amp;gt;override public init(frame: CGRect) {
  super.init(frame: frame)
  commonInit()
}&lt;/noscript&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;required public init?(coder: NSCoder) {
    super.init(coder: coder)
    commonInit()
}&lt;/p&gt;

&lt;p&gt;open func commonInit() {
    if let view = Bundle.main.loadNibNamed(&quot;CustomView&quot;, owner: self, options: nil)?.first as? UIView {
        view.frame = self.bounds
        self.addSubview(view)
    }
}&amp;lt;/pre&amp;gt;&amp;lt;/noscript&amp;gt;&lt;script src=&quot;https://gist.github.com/RoKang/afb8acf15ff66017fcf3311114b06595.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;2번 초기화 방법&lt;/strong&gt;&lt;noscript&gt;&amp;lt;pre&amp;gt;class func instanceFromNib() -&amp;gt; CustomView? {
  let instance = Bundle.main.loadNibNamed(&quot;CustomView&quot;, owner: self, options: nil)?.lazy.filter{$0 is CustomView}.first as? CustomView
  return instance
}&amp;lt;/pre&amp;gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/RoKang/c1b1dd0771cb9eeea2dee7c7f19b87bb.js&quot;&gt; &lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;placeholders와-files-owner&quot;&gt;Placeholders와 File’s Owner&lt;/h2&gt;
&lt;p&gt;제가 찾아봤을 때 CustomView를 만들 때 주로 사용하는 방법은 1번이었습니다. &lt;strong&gt;여기서 한 가지 의문이 생깁니다.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;UITableViewCell이나 UICollectionViewCell을 nib과 함께 생성하면 IB에서 File’s Owner가 아니라 Cell Object에 연결되던데 &lt;strong&gt;왜 CustomView는 File’s Owner에 연결해서 사용하는가?&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일단 nib 파일의 Placeholders와 File’s Owner가 무엇인지부터 알아야겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
    &lt;img src=&quot;../images/2020-04-22-iOS-custom-view/1.png&quot; alt=&quot;일반적으로 CustomView를 File's Owner의 Custom Class로 쓸 때&quot; /&gt;
    &lt;figcaption style=&quot;color: dimgray; font-size: 14px; text-align: center;&quot;&gt;일반적으로 CustomView를 File's Owner의 Custom Class로 쓸 때&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
    &lt;img src=&quot;../images/2020-04-22-iOS-custom-view/2.png&quot; alt=&quot;UITableViewCell의 xib를 자동 생성했을 때&quot; /&gt;
    &lt;figcaption style=&quot;color: dimgray; font-size: 14px; text-align: center;&quot;&gt;UITableViewCell의 xib를 자동 생성했을 때&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-files-owner&quot;&gt;1. File’s Owner&lt;/h3&gt;
&lt;p&gt;먼저 &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html&quot;&gt;Nib Files&lt;/a&gt; 공식 문서에 있는 File’s Owner의 내용 중 일부를 나름대로 번역해봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2020-04-22-iOS-custom-view/3.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;nib 파일 안의 객체들 중 가장 중요한 것 중 하나가 File’s Owner 객체이다. Interface objects와 다르게, File’s Owner 객체는 &lt;strong&gt;placeholder 객체&lt;/strong&gt;로서 nib 파일이 로드 될 때 생성되지 않는다. 대신, &lt;strong&gt;개발자가 코드 상에서 이 객체를 생성하고 nib-loading code에 전달해야 한다.&lt;/strong&gt; 이 객체가 application 코드와 nib 파일의 컨텐츠 사이의 main link로서 너무나도 중요하기 때문이다. &lt;strong&gt;구체적으로 말하자면, File’s Owner는 nib 파일의 컨텐츠를 책임지는 Controller object다.&lt;/strong&gt;
&lt;br /&gt;&lt;br /&gt;
Xcode에서 개발자는 nib 파일에서 File’s Owner와 다른 interface objects 사이의 connection들을 생성할 수 있다. &lt;strong&gt;nib 파일을 로드 할 때, nib-loading code는 개발자가 명시한 replacement object를 사용해서 이 connection들을 재생성한다.&lt;/strong&gt; 이는 객체를 nib 파일 안의 reference objects가 되도록 허용하고, interface objects로 부터 발생한 메시지들을 자동으로 수신하게 해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;😁 모든 내용을 이해하기 어렵지만(저는ㅎㅎ), 유의깊게 봐야할 부분은 File’s Owner가 placeholder 객체라는 점인 것 같습니다. 저는 이 placeholder의 의미를 &lt;strong&gt;‘nib을 소유할 실제 클래스의 타입(인스턴스가 아닌)을 가리키기 위한 것’&lt;/strong&gt;이라고 이해했습니다. 즉, IB에서는 타입만을 지정해주고 실제 인스턴스를 File’s Owner로 지정하는 것이죠.&lt;/p&gt;

&lt;p&gt;이제 Placeholders와 File’s Owner가 무엇인지 대충 감은 잡은 것 같습니다. Placeholders 안에 First Responder도 포함되어 있는데 이 내용은 나중에 따로 정리할 예정입니다. 이제 File’s Owner 인스턴스를 어떻게 &lt;strong&gt;전달&lt;/strong&gt;하는지 알아보려합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-loadnibnamed_owneroptions&quot;&gt;2. loadNibNamed(_:owner:options:)&lt;/h3&gt;
&lt;noscript&gt;&lt;pre&gt;override init(frame: CGRect) {
    super.init(frame: frame)
    commonInit()
}

required init?(coder: NSCoder) {
    super.init(coder: coder)
    commonInit()
}

private func commonInit() {
    if let view = Bundle.main.loadNibNamed(&amp;quot;CustomView&amp;quot;, owner: self, options: nil)?.first as? UIView {
        view.frame = self.bounds
        self.addSubview(view)
    }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/7089f0772ba0ed49e056115487afe626.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;CustomView를 만들기 위해 구글링을 하면 대부분의 블로그에 이 코드가 포함되어 있습니다. 메인 Bundle에서 “CustomView” 라는 이름을 가진 nib 파일에 대한 unarchiving, initialize, reestablishing의 과정을 거친 뒤, 해당 nib 파일에 있는 &lt;strong&gt;top-level objects&lt;/strong&gt;를 &lt;strong&gt;[Any]&lt;/strong&gt;의 형태로 리턴해주죠.(&lt;strong&gt;top-level objects&lt;/strong&gt;는 간략하게 IB 좌측 Placeholders 아래에 있는 최상단 object 리스트라고 생각하시면 될 것 같습니다. &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html&quot;&gt;Nib Files&lt;/a&gt; 공식 문서에 이에 대한 설명이 포함되어 있습니다)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;loadNibNamed&lt;/strong&gt; 메서드에 &lt;strong&gt;owner&lt;/strong&gt; 라는 파라미터가 포함되어 있습니다. File’s Owner 인스턴스가 이 &lt;strong&gt;owner&lt;/strong&gt;릍 통해서 전달됩니다. IB에서 File’s Owner와 연결했던 outlet들이 실제 owner인 CustomView의 인스턴스와 연결되겠네요.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;CustomView에 대한 구글링을 해보면 &lt;strong&gt;coding-compliant Error&lt;/strong&gt;에 대한 질문이 종종 보이는데, 이 에러가 발생하는 이유는 1번 방법으로 CustomView를 만들 때, owner를 nil로 설정하기 때문에 발생합니다. File’s Owner에 outlet을 만들어놨는데 실제 인스턴스가 File’s Owner로 전달되지 않으면 outlet pointer를 재연결하기 위해 실행되는 &lt;strong&gt;setValue:forKey:&lt;/strong&gt; 메서드에서 에러가 발생하는 것이죠.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;uitableviewcontroller-uitableviewcell&quot;&gt;UITableViewController, UITableViewCell&lt;/h2&gt;

&lt;p&gt;그렇다면 왜 Xcode에서 UITableViewCell nib을 자동 생성할 때 1번 방법이 아닌 2번 방법으로 CustomView를 만들까요?&lt;/p&gt;

&lt;p&gt;지금은 &lt;code class=&quot;highlighter-rouge&quot;&gt;dequeueReusableCell&lt;/code&gt; 에서 nil이 리턴되지 않지만 예전에는 이 메서드에서 nil을 뱉어내는 경우가 있었습니다.(재활용할 cell이 memory에 없을 경우겠죠) 그 때를 대비해서 cell을 직접 생성하는 코드를 작성해주어야 했습니다. 그 코드를 보면 UITableViewCell의 nib이 어떻게 로드되는지 알 수 있습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;if let cell = Bundle.main.loadNibNamed(&amp;quot;CustomTableViewCell&amp;quot;, owner: self, options: nil)?.first as? CustomTableViewCell {
    return cell
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/a12cda61d69c077d2bffae395c846d22.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;여기서 self는 &lt;code class=&quot;highlighter-rouge&quot;&gt;UITableViewController&lt;/code&gt;입니다.&lt;code class=&quot;highlighter-rouge&quot;&gt;File's Owner는 nib 파일의 컨텐츠를 책임지는 Controller object다&lt;/code&gt; 라는 내용을 공식 문서에서 확인했습니다. 이걸 테이블 뷰에 적용해보면 nib 파일이 로드 될 때 각 cell의 UI outlet은 &lt;strong&gt;top-level objects 중 CustomCell&lt;/strong&gt;과 연결되고 File’s Owner는 &lt;strong&gt;UITableViewController&lt;/strong&gt;가 되어 테이블 뷰에 포함된 모든 cell의 컨텐츠를 책임지게 되겠네요. 생각해보면 UITableViewController는 생성된 cell에 대한 터치 등등 어플리케이션의 이벤트들을 대신 핸들링해주는 역할을 담당합니다.&lt;/p&gt;

&lt;p&gt;즉, UITableViewCell이 2번 방법으로 생성되는 이유는 File’s Owner를 UITableViewController 인스턴스로 설정하기 위함이었다고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;어떤-방법이-적합할까&quot;&gt;어떤 방법이 적합할까?&lt;/h2&gt;
&lt;p&gt;그렇다면 CustomView도 UITableViewCell에서 자동 생성되는 nib처럼 &lt;strong&gt;2번 방법&lt;/strong&gt;을 따라야 할까요? UITableViewController에서 셀을 다룰 때는 dequeueReusableCell나 cellForRowAtIndexPath와 같은 시스템 메서드를 사용하지만, 일반 CustomView는 그렇지 않습니다. 초기화 코드를 직접 작성해야하죠.&lt;/p&gt;

&lt;p&gt;그럼 1번 방법을 따르는 게 옳을까요? 생각해보면 xib 자체가 여러 개의 &lt;strong&gt;top-level object&lt;/strong&gt;를 포함할 수 있게 만들어져 있기 때문에 File’s Owner가 1개의 UIView 클래스로 지정되는 것도 IB 설계의 방향성에 부합되지 않아 보입니다. 또한 Controller object의 역할을 하는 File’s Owner에 UIView가 알맞은 후보라고 할 수도 없는 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;결론-및-정리&quot;&gt;결론 및 정리&lt;/h2&gt;
&lt;p&gt;많은 시간을 들였지만 어떤 방법이 조금 더 코코아터치 프레임워크에 적합한지 명확하게 찾아낼 수는 없었습니다. 
다만, File’s Owner의 정의를 깊이 고민해본다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;1번 방법보다는 2번 방법이 더 옳은 방법이 아닐까 싶습니다.&lt;/code&gt;
1개의 xib에서 1개의 View만을 표현하도록 강제하고 싶다면 1번 방법이 목적에 더 부합한다고 볼 수도 있겠지만 말이죠.&lt;/p&gt;

&lt;p&gt;읽어주셔서 감사합니다. 피드백은 언제나 환영입니다. 🚀&lt;/p&gt;</content><author><name></name></author><category term="Swift" /><category term="iOS" /><summary type="html">CustomView는 같은 UI를 가지는 View들을 하나의 공통된 View로 묶어 재사용하기 위해 만듭니다. 중복을 줄여주는 장점 때문에 저는 되도록 만들어 쓰는 편입니다. CustomView를 만드는 방법은 쉽게 찾아볼 수 있고 2가지로 나뉘더군요. 그 2개의 방법의 차이점을 파악하고 어떤 방법이 더 나은지를 확인하고자 합니다.</summary></entry><entry><title type="html">JSON과 Codable</title><link href="http://localhost:4000/swift-json-codable/" rel="alternate" type="text/html" title="JSON과 Codable" /><published>2020-02-20T00:00:00+09:00</published><updated>2020-02-20T00:00:00+09:00</updated><id>http://localhost:4000/swift-json-codable</id><content type="html" xml:base="http://localhost:4000/swift-json-codable/">&lt;p&gt;앱 개발을 할 때 JSON 데이터 처리는 기본이면서도 정말 중요합니다. 기존에는 JSON을 주먹구구식으로 핸들링하거나 &lt;code class=&quot;highlighter-rouge&quot;&gt;SwiftyJSON&lt;/code&gt;을 사용했었는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;Swift4&lt;/code&gt;에서 새로 도입된 &lt;code class=&quot;highlighter-rouge&quot;&gt;Codable&lt;/code&gt;을 알게되서 이 프로토콜을 사용하여 JSON 데이터를 더 깔끔하게 처리하는 방법을 정리하고자 합니다.&lt;/p&gt;

&lt;h1 id=&quot;json-예시&quot;&gt;JSON 예시&lt;/h1&gt;
&lt;!-- JSON 예제 코드 --&gt;
&lt;noscript&gt;&lt;pre&gt;{
  &amp;quot;data&amp;quot;: {
    &amp;quot;room&amp;quot;: [
      {
        &amp;quot;name&amp;quot;: &amp;quot;room1&amp;quot;,
        &amp;quot;order&amp;quot;: 1,
        &amp;quot;messages&amp;quot;: [
          {
            &amp;quot;content&amp;quot;: &amp;quot;Mom&amp;quot;,
            &amp;quot;person&amp;quot;: &amp;quot;Tom&amp;quot;,
            &amp;quot;order&amp;quot;: 1
          },
          {
            &amp;quot;content&amp;quot;: &amp;quot;I&amp;#39;m sorry&amp;quot;,
            &amp;quot;person&amp;quot;: &amp;quot;Will&amp;quot;,
            &amp;quot;order&amp;quot;: 2
          },
          {
            &amp;quot;content&amp;quot;: &amp;quot;Thank you&amp;quot;,
            &amp;quot;person&amp;quot;: &amp;quot;Big brother Tom&amp;quot;,
            &amp;quot;order&amp;quot;: 3
          }
        ]
      }
    ]
  }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/cf87c669c296a5392395a7e1eb0f9561.js&quot;&gt; &lt;/script&gt;

&lt;h1 id=&quot;before&quot;&gt;Before&lt;/h1&gt;
&lt;p&gt;위의 예시를 바탕으로 기존에 작성했던 코드는 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;JSONSerialization 객체로 JSON을 Foundation 객체로 변환했습니다. Nested(중첩) JSON이기 때문에 Dictionary로 계속 변환해주었는데 가독성에 문제도 있고, 서버에서 JSON 구조를 변경하게 되면 그에 맞게 코드를 수정하기가 까다롭습니다. 가만히 두고 볼 수 없는 코드입니다.
&lt;!-- 하드하게 디코딩한 코드 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;if let data = jsonString.data(using: .utf8) {
    if let decoded = try? JSONSerialization.jsonObject(with: data, options: []) {
        let dataDic = (decoded as? [String: Any])?[&amp;quot;data&amp;quot;] as? [String: Any] ?? [:]
        let roomArray = dataDic[&amp;quot;room&amp;quot;] as? [[String: Any]] ?? []

        for room in roomArray {
            print(room[&amp;quot;name&amp;quot;])
            print(room[&amp;quot;order&amp;quot;])
            
            let messages = room[&amp;quot;messages&amp;quot;] as? [[String: Any]] ?? []
            
            for msg in messages {
                print(msg[&amp;quot;content&amp;quot;])
                print(msg[&amp;quot;person&amp;quot;])
                print(msg[&amp;quot;order&amp;quot;])
            }
        }
    }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/550a3febcce5421f7020a9ef5185c389.js&quot;&gt; &lt;/script&gt;

&lt;h1 id=&quot;codable&quot;&gt;Codable&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Codable&lt;/code&gt;을 적용하기 전에 이 프로토콜이 어떤 역할을 하는지 알아야 할 필요가 있습니다. Codable은 Decodable과 Encodable을 포함하는 프로토콜이라고 &lt;a href=&quot;https://developer.apple.com/documentation/swift/codable&quot; target=&quot;blank&quot;&gt;애플 공식 문서&lt;/a&gt;에 나와있네요. &lt;a href=&quot;https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types&quot; target=&quot;blank&quot;&gt;Encoding and Decoding Custom Types&lt;/a&gt;에서 Swift는 데이터를 인코딩하고 디코딩하는 표준화 된 접근법을 정의하고 있으며, 이 접근법은 Decodable과 Encodable 프로토콜을 적용한 방법이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types&quot; target=&quot;blank&quot;&gt;Encoding and Decoding Custom Types&lt;/a&gt;는 공식 문서로서 커스텀 타입을 인코딩, 디코딩 하는 방법이 잘 설명되어 있으니 꼭 참고하시길 바랍니다.&lt;/p&gt;

&lt;h1 id=&quot;codingkey&quot;&gt;CodingKey&lt;/h1&gt;
&lt;p&gt;Codable을 적용하게 되면 이 &lt;a href=&quot;https://developer.apple.com/documentation/swift/codingkey&quot; target=&quot;blank&quot;&gt;CodingKey&lt;/a&gt;라는 것도 필요합니다. CodingKey는 인코딩과 디코딩을 위한 키로 쓰이는 &lt;strong&gt;타입&lt;/strong&gt;입니다. 그럼 이제 JSON 예시에 맞게 코드를 바꿔보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;struct-with-codable&quot;&gt;Struct with Codable&lt;/h1&gt;
&lt;p&gt;예시로 든 JSON에는 room key와 messages key안에 배열로 된 데이터가 있습니다. 따라서 &lt;strong&gt;Result &amp;gt; Room &amp;gt; Message&lt;/strong&gt; 집합 관계로 정의된 구조체에 Codable을 적용했습니다. 또한, CodingKey 프로토콜을 상속받은 CodingKeys의 case가 json 데이터의 key로 매핑되는 것을 알 수 있습니다. 예를 들어, &lt;strong&gt;Result의 rooms&lt;/strong&gt;에는 &lt;strong&gt;room&lt;/strong&gt; key에 해당하는 value가 매핑됩니다.
&lt;!-- Codable 적용한 구조체 코드 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;struct Result: Codable {
    var success: Bool?
    var reason: String?
    var rooms: [Room]?
    
    enum CodingKeys: String, CodingKey {
        case success, reason, rooms = &amp;quot;room&amp;quot;
        case data = &amp;quot;data&amp;quot;
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let data = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .data)
        
        success = try container.decode(Bool.self, forKey: .success)
        reason = try container.decode(String.self, forKey: .reason)
        rooms = try data.decode([Room].self, forKey: .rooms)
    }
}

struct Room: Codable {
    var name: String?
    var order: Int?
    var messages: [Message]?
    
    enum CodingKeys: String, CodingKey {
        case name, order, messages
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        name = try container.decode(String.self, forKey: .name)
        order = try container.decode(Int.self, forKey: .order)
        messages = try container.decode([Message].self, forKey: .messages)
    }
}

struct Message : Codable {
    var content: String?
    var person: String?
    var order: Int?
    
    enum CodingKeys: String, CodingKey {
        case content, person, order
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        content = try container.decode(String.self, forKey: .content)
        person = try container.decode(String.self, forKey: .person)
        order = try container.decode(Int.self, forKey: .order)
    }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/e665070d5d6d6b873446e217e2ea8072.js&quot;&gt; &lt;/script&gt;

&lt;h1 id=&quot;after&quot;&gt;After&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;try? JSONDecoder().decode(Result.self, from: data)&lt;/code&gt; 코드 한 줄로 Result, Room, Message 데이터까지 깔끔하게 처리할 수 있게 되었습니다.
표준 라이브러리 설명과 함께 코드를 보면서 어떻게 동작하는지 좀 더 자세하게 살펴보겠습니다.
&lt;!-- Codable이 적용된 구조체로 디코딩하는 예제 코드 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;let data = jsonString.data(using: .utf8) ?? Data()
if let result = try? JSONDecoder().decode(Result.self, from: data) {
    print(&amp;quot;success : \(result.success ?? false)&amp;quot;)
    print(&amp;quot;reason : \(result.reason ?? &amp;quot;&amp;quot;)\n&amp;quot;)
    
    result.rooms?.forEach{ room in
        print(&amp;quot;  name : \(room.name ?? &amp;quot;&amp;quot;)&amp;quot;)
        print(&amp;quot;  order : \(room.order ?? 0)\n&amp;quot;)
        
        room.messages?.forEach { message in
            print(&amp;quot;    content : \(message.content ?? &amp;quot;&amp;quot;)&amp;quot;)
            print(&amp;quot;    person : \(message.person ?? &amp;quot;&amp;quot;)&amp;quot;)
            print(&amp;quot;    order : \(message.order ?? 0)\n&amp;quot;)
        }
    }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/5a0e1026e5313142c2db2a216bea93d3.js&quot;&gt; &lt;/script&gt;

&lt;h3 id=&quot;1-json-데이터를-특정-타입으로-decoding&quot;&gt;1. JSON 데이터를 특정 타입으로 Decoding&lt;/h3&gt;
&lt;p&gt;decode 메서드는 디코딩 될 data로부터 Result 타입의 value를 만들어줍니다.
&lt;!-- 표준 라이브러리 코드 1 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;if let result = try? JSONDecoder().decode(Result.self, from: data)

/// decode 표준 라이브러리

/// Decodes a top-level value of the given type from the given JSON representation.
///
/// - parameter type: The type of the value to decode.
/// - parameter data: The data to decode from.
/// - returns: A value of the requested type.
/// - throws: `DecodingError.dataCorrupted` if values requested from the payload are corrupted, or if the given data is not valid JSON.
/// - throws: An error if any value throws an error during decoding.
open func decode&amp;lt;T&amp;gt;(_ type: T.Type, from data: Data) throws -&amp;gt; T where T : Decodable&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/3f1252e502a98ce31801600d325a9d32.js&quot;&gt; &lt;/script&gt;

&lt;h3 id=&quot;2-데이터로부터-container-생성&quot;&gt;2. 데이터로부터 container 생성&lt;/h3&gt;
&lt;p&gt;1번 코드가 Result를 초기화하는 init 코드를 실행하고 decoder에 담겨있던 data로부터 container를 생성해줍니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;CodingKeys.self&lt;/code&gt; 타입이 data의 key와 매핑이 되지 않는다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;DecodingError.typeMismatch&lt;/code&gt; 에러를 던지겠네요.
&lt;!-- 표준 라이브러리 코드 2 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;let container = try decoder.container(keyedBy: CodingKeys.self)

/// container 

/// Returns the data stored in this decoder as represented in a container
/// keyed by the given key type.
///
/// - parameter type: The key type to use for the container.
/// - returns: A keyed decoding container view into this decoder.
/// - throws: `DecodingError.typeMismatch` if the encountered stored value is
///   not a keyed container.
func container&amp;lt;Key&amp;gt;(keyedBy type: Key.Type) throws -&amp;gt; KeyedDecodingContainer&amp;lt;Key&amp;gt; where Key : CodingKey&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/c1e77fd8d79dc5816d67cd85b08ea030.js&quot;&gt; &lt;/script&gt;

&lt;h3 id=&quot;3-container에서-nestedcontainer-생성&quot;&gt;3. container에서 nestedContainer 생성&lt;/h3&gt;
&lt;p&gt;Nested JSON이기 때문에 해당 키에 대한 sub container(=nestedContainer)를 생성해줍니다.
&lt;!-- 표준 라이브러리 코드 3 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;let data = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .data)

///  nestedContainer 표준 라이브러리

/// Returns the data stored for the given key as represented in a container
/// keyed by the given key type.
///
/// - parameter type: The key type to use for the container.
/// - parameter key: The key that the nested container is associated with.
/// - returns: A keyed decoding container view into `self`.
/// - throws: `DecodingError.typeMismatch` if the encountered stored value is
///   not a keyed container.
public func nestedContainer&amp;lt;NestedKey&amp;gt;(keyedBy type: NestedKey.Type, forKey key: KeyedDecodingContainer&amp;lt;K&amp;gt;.Key) throws -&amp;gt; KeyedDecodingContainer&amp;lt;NestedKey&amp;gt; where NestedKey : CodingKey&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/0c1a401def1d28b496f0bf3947560525.js&quot;&gt; &lt;/script&gt;

&lt;h3 id=&quot;4-nestedcontainer에서-room-데이터-디코딩&quot;&gt;4. nestedContainer에서 [Room] 데이터 디코딩&lt;/h3&gt;
&lt;p&gt;Room 타입도 Codable을 상속받은 구조체이기 때문에 이 과정에서 Room도 디코딩이 진행되고 마찬가지로 Message도 디코딩이 이루어집니다.
&lt;!-- 표준 라이브러리 코드 4 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;rooms = try data.decode([Room].self, forKey: .rooms)

/// decode 표준 

/// Decodes a value of the given type for the given key.
///
/// - parameter type: The type of value to decode.
/// - parameter key: The key that the decoded value is associated with.
/// - returns: A value of the requested type, if present for the given key
///   and convertible to the requested type.
/// - throws: `DecodingError.typeMismatch` if the encountered encoded value
///   is not convertible to the requested type.
/// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
///   for the given key.
/// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
///   the given key.
public func decode&amp;lt;T&amp;gt;(_ type: T.Type, forKey key: KeyedDecodingContainer&amp;lt;K&amp;gt;.Key) throws -&amp;gt; T where T : Decodable&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/a56af6bb733cf19bebbbf177f460d831.js&quot;&gt; &lt;/script&gt;

&lt;h1 id=&quot;tip&quot;&gt;Tip&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;바닐라 Codable도 JSONSerialization을 사용한 방법에 비해서 훨씬 편해졌지만, &lt;a href=&quot;https://github.com/JohnSundell/Codextended&quot; target=&quot;blank&quot;&gt;Codextended&lt;/a&gt;는 Codable 코드를 더 깔끔하게 만들어줍니다. Codable에 익숙해진다면 고려해 볼 만한 옵션인 것 같습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;날짜 JSON 데이터를 Date 타입으로 포맷팅하는건 생각보다 귀찮은 일 입니다. 그래서 Codable에는 어떤 날짜 데이터가 &lt;strong&gt;특정 포맷에 맞다면 자동으로 Date 인스턴스로 디코딩 해주는 strategy(전략)&lt;/strong&gt;이 포함되어 있습니다.&lt;/p&gt;

    &lt;p&gt;formatter 인스턴스를 만들어서 원하는 포맷의 데이터를 Date로 변환할 수도 있고 iso8601 옵션처럼 표준화 된 포맷을 적용할 수도 있습니다. 저는 &lt;strong&gt;formatted&lt;/strong&gt;나 &lt;strong&gt;iso8601&lt;/strong&gt; 옵션을 많이 활용하게 될 것 같습니다.
&lt;!-- JSONDecoder().dateDecodingStrategy 예제 코드 1 --&gt;&lt;noscript&gt;&amp;lt;pre&amp;gt;let formatter = DateFormatter()
formatter.dateFormat = &quot;yyyy.MM.dd&quot;
JSONDecoder().dateDecodingStrategy = .formatted(formatter)
JSONDecoder().dateDecodingStrategy = .iso8601
JSONDecoder().dateDecodingStrategy = .millisecondsSince1970
JSONDecoder().dateDecodingStrategy = .secondsSince1970&amp;lt;/pre&amp;gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/RoKang/fa262e9d404d05cf4c7938978fbf7043.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;
&lt;p&gt;정리한 내용이 디코딩만을 다루고 있지만, 인코딩은 JSONEncoder 클래스를 활용한 반대의 과정이기 때문에 디코딩을 잘 알고 있다면 어렵지 않을 것 같습니다.&lt;/p&gt;

&lt;p&gt;내용 중 오류가 있거나 궁금하신 점이 있다면 댓글 남겨주시면 감사하겠습니다 :)&lt;/p&gt;</content><author><name></name></author><category term="Swift" /><category term="iOS" /><category term="JSON" /><category term="Codable" /><summary type="html">앱 개발을 할 때 JSON 데이터 처리는 기본이면서도 정말 중요합니다. 기존에는 JSON을 주먹구구식으로 핸들링하거나 SwiftyJSON을 사용했었는데, Swift4에서 새로 도입된 Codable을 알게되서 이 프로토콜을 사용하여 JSON 데이터를 더 깔끔하게 처리하는 방법을 정리하고자 합니다.</summary></entry></feed>