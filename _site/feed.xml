<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-04-24T10:48:12+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">강뱅</title><subtitle>cooool</subtitle><entry><title type="html">CustomView에 대한 고찰</title><link href="http://localhost:4000/iOS-custom-view/" rel="alternate" type="text/html" title="CustomView에 대한 고찰" /><published>2020-04-22T00:00:00+09:00</published><updated>2020-04-22T00:00:00+09:00</updated><id>http://localhost:4000/iOS-custom-view</id><content type="html" xml:base="http://localhost:4000/iOS-custom-view/">&lt;p&gt;CustomView는 같은 UI를 가지는 View들을 하나의 공통된 View로 묶어 &lt;strong&gt;재사용&lt;/strong&gt;하기 위해 만듭니다. &lt;strong&gt;불필요한 코드의 중복을 줄이고 유지보수를 쉽게&lt;/strong&gt; 해주기 때문에 저는 되도록 만들어 쓰는 편입니다. CustomView를 만드는 건 이미 많은 블로그에 설명되어 있기 때문에 만드는 방법 보다 &lt;code class=&quot;highlighter-rouge&quot;&gt;CustomView를 만들면서 생긴 호기심&lt;/code&gt;을 풀어가는 과정에 집중하여 정리하고자 합니다.&lt;/p&gt;

&lt;p&gt;내용이 많을 듯하여 나중에 글을 다시 정리할 때는 여러 개의 포스트로 쪼개야 할 것 같습니다ㅠ&lt;/p&gt;

&lt;p&gt;시작해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;customview를-만드는-2가지-방법&quot;&gt;CustomView를 만드는 2가지 방법&lt;/h2&gt;
&lt;p&gt;먼저 CustomView를 만드는 두 개의 방법을 알아보겠습니다.(여기서 IB란 Interface Builder를 말합니다)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;IB에서 File’s Owner에 CustomView 클래스를 설정하고 outlet을 연결한다.&lt;/li&gt;
    &lt;li&gt;IB에서 view object에 CustomView 클래스를 설정하고 outlet을 연결한다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;두 개의 방법은 IB에서의 차이점도 있지만 뷰를 초기화하는 코드에도 차이점이 있습니다.
(지금부터는 편의상 CustomView 만드는 방법에 대한 명칭을 1번, 2번으로 지칭하겠습니다.)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1번 방법의 코드&lt;/li&gt;
  &lt;li&gt;2번 방법의 코드&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;placeholders와-files-owner&quot;&gt;Placeholders와 File’s Owner&lt;/h2&gt;
&lt;p&gt;구글링을 했을 때 CustomView를 만들 때 가장 많이 사용하는 방법은 1번 방법이었습니다. Placeholders와 File’s Owner가 정확히 무엇인지 모르는 상태에서 한 가지 의문이 생겼습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;아니, UITableViewCell이나 UICollectionViewCell을 만들면 Interface Builder에 File’s Owner가 아니라 Cell Object에 연결되던데 &lt;strong&gt;왜 CustomView는 File’s Owner에 연결해서 사용하지?&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 호기심을 해결하기 위해 먼저 nib 파일의 Placeholders와 File’s Owner가 무엇인지 파악해야 할 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
    &lt;img src=&quot;../images/2020-04-22-iOS-custom-view/1.png&quot; alt=&quot;일반적으로 CustomView를 File's Owner의 Custom Class로 쓸 때&quot; /&gt;
    &lt;figcaption style=&quot;color: dimgray; font-size: 14px; text-align: center;&quot;&gt;일반적으로 CustomView를 File's Owner의 Custom Class로 쓸 때&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
    &lt;img src=&quot;../images/2020-04-22-iOS-custom-view/2.png&quot; alt=&quot;UITableViewCell의 xib를 자동 생성했을 때&quot; /&gt;
    &lt;figcaption style=&quot;color: dimgray; font-size: 14px; text-align: center;&quot;&gt;UITableViewCell의 xib를 자동 생성했을 때&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-files-owner&quot;&gt;1. File’s Owner&lt;/h3&gt;
&lt;p&gt;먼저 &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html&quot;&gt;Nib Files&lt;/a&gt; 공식 문서에 있는 File’s Owner의 내용 중 일부를 나름대로(?) 번역해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2020-04-22-iOS-custom-view/3.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;nib 파일 안의 객체들 중 가장 중요한 것 중 하나가 File’s Owner 객체이다. Interface objects와 다르게, File’s Owner 객체는 &lt;strong&gt;placeholder 객체&lt;/strong&gt;로서 nib 파일이 로드 될 때 생성되지 않는다. 대신, &lt;strong&gt;개발자가 코드 상에서 이 객체를 생성하고 nib-loading code에 전달해야 한다.&lt;/strong&gt; 이 객체가 application 코드와 nib 파일의 컨텐츠 사이의 main link로서 너무나도 중요하기 때문이다. &lt;strong&gt;구체적으로 말하자면, File’s Owner는 nib 파일의 컨텐츠 들을 책임지는 Controller object다.&lt;/strong&gt;
&lt;br /&gt;&lt;br /&gt;
Xcode에서 개발자는 nib 파일에서 File’s Owner와 다른 interface objects 사이의 connection들을 생성할 수 있다. &lt;strong&gt;nib 파일을 로드 할 때, nib-loading code는 개발자가 명시한 replacement object를 사용해서 이 connection들을 재생성한다.&lt;/strong&gt; 이는 객체를 nib 파일 안의 reference objects가 되도록 허용하고, interface objects로 부터 발생한 메시지들을 자동으로 수신하게 해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;솔직히 모든 내용을 이해하기 어려웠지만(😁), 여기서 유의깊게 봐야할 부분은 File’s Owner가 placeholder 객체라는 점인 것 같습니다. 저는 이 placeholder의 의미를 &lt;strong&gt;nib을 소유할 클래스의 타입(인스턴스가 아닌)을 설정하는 것&lt;/strong&gt;이라고 이해했습니다. 즉, Interface Builder에서는 타입만을 지정해주고 실제 객체는 코드 상에서 만든 인스턴스를 전달하여 File’s Owner로 지정하는 것이죠.&lt;/p&gt;

&lt;p&gt;이제 Placeholders와 File’s Owner가 무엇인지 대충 감은 잡은 것 같습니다. Placeholders 안에 First Responder도 포함되어 있는데 이 내용은 따로 정리해놓을 예정입니다. 다음은 File’s Owner 객체를 어떻게 &lt;strong&gt;전달&lt;/strong&gt;하는지 알아봐야겠네요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-loadnibnamed_owneroptions&quot;&gt;2. loadNibNamed(_:owner:options:)&lt;/h3&gt;
&lt;noscript&gt;&lt;pre&gt;override init(frame: CGRect) {
    super.init(frame: frame)
    commonInit()
}

required init?(coder: NSCoder) {
    super.init(coder: coder)
    commonInit()
}

private func commonInit() {
  if let view = Bundle.main.loadNibNamed(&amp;quot;CustomView&amp;quot;, owner: self, options: nil)?.first as? UIView {
        view.frame = self.bounds
        self.addSubview(view)
    }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/7089f0772ba0ed49e056115487afe626.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;CustomView를 만들기 위해 구글링을 하면 대부분의 블로그에 이 코드가 포함되어 있습니다. 메인 Bundle에서 “CustomView” 라는 이름을 가진 nib 파일에 대한 unarchiving, initialize, reestablishing의 과정을 거친 뒤, 해당 nib 파일에 있는 &lt;strong&gt;top-level objects&lt;/strong&gt;를 &lt;strong&gt;[Any]&lt;/strong&gt;의 형태로 리턴해주죠.(&lt;strong&gt;top-level objects&lt;/strong&gt;에 대한 내용도 따로 다루기에는 너무 내용이 많을 것 같아서 공식 문서로 대체하겠습니다 -&amp;gt; &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html&quot;&gt;여기있습니다!&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;loadNibNamed&lt;/strong&gt; 메서드를 잘 살펴보면 &lt;strong&gt;owner&lt;/strong&gt; 라는 파라미터가 있습니다. File’s Owner 객체를 여기서 &lt;strong&gt;전달&lt;/strong&gt;하네요. owner가 self 즉, &lt;strong&gt;CustomView의 인스턴스&lt;/strong&gt;가 되면서 IB에서 File’s Owner와 연결했던 outlet(=connection)들이 해당 인스턴스에 할당됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;CustomView에 대한 구글링을 해보면 coding-compliant에 에러에 대한 질문이 종종 보이는데, 이 에러가 발생하는 이유는 owner를 nil로 설정하기 때문에 발생합니다. File’s Owner에 outlet을 만들어놨는데 해당 클래스의 File’s Owner 객체가 전달되지 않으면 outlet pointer를 재연결하기 위해 실행되는 &lt;strong&gt;setValue:forKey:&lt;/strong&gt; 메서드에서 에러가 발생하는 것이죠.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tableviewcontroller와-tableviewcell&quot;&gt;TableViewController와 TableViewCell&lt;/h2&gt;
&lt;p&gt;File’s Owner로 CustomView를 만드는 일반적인 과정을 파악했습니다. 이제 다시 의문점으로 돌아가서, 왜 TableViewCell은 IB에서 cell object에 custom class를 설정하는지 알아보겠습니다.&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;tableView.register(CustomTableViewCell.self, forCellReuseIdentifier: &amp;quot;CustomTableViewCell&amp;quot;)
// OR
tableView.register(UINib(nibName: &amp;quot;CustomTableViewCell&amp;quot;, bundle: nil), forCellReuseIdentifier: &amp;quot;CustomTableViewCell&amp;quot;)&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/d3d9eae430a8c218fc0ed3ae6a0d4c6d.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;보통 테이블 뷰에서 custom cell을 사용할 때, register 메서드로 &lt;strong&gt;테이블 뷰가 어떻게 cell을 생성하는지 지정해줍니다.&lt;/strong&gt; 그리고 테이블 뷰의 &lt;code class=&quot;highlighter-rouge&quot;&gt;dequeueReusableCell&lt;/code&gt; 메서드로 cell을 재활용하죠.&lt;/p&gt;

&lt;p&gt;하지만 좀 다르게 cell을 로드하고 재활용하는 방법도 있습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;if let cell = Bundle.main.loadNibNamed(&amp;quot;CustomTableViewCell&amp;quot;, owner: self, options: nil)?.first as? CustomTableViewCell {
    return cell
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/a12cda61d69c077d2bffae395c846d22.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;여기서 중요한 건 &lt;strong&gt;owner가 self&lt;/strong&gt; 라는 점입니다. 여기서 self는 테이블 뷰의 &lt;code class=&quot;highlighter-rouge&quot;&gt;컨트롤러&lt;/code&gt;입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;File's Owner는 nib 파일의 컨텐츠를 책임지는 Controller object다&lt;/code&gt; 라는 내용을 공식 문서에서 확인했었습니다. 이걸 테이블 뷰에 적용해보면 nib 파일이 로드 될 때 각 cell의 UI outlet은 custom cell object가 연결되어 담당하게 되고 File’s Owner는 테이블 뷰 컨트롤러가 되어 테이블 뷰에 포함된 모든 cell의 컨텐츠를 책임지게 되겠네요. 생각해보면 cell의 터치 이벤트를 포함한 다양한 이벤트는 테이블 뷰 컨트롤러가 담당하고 있습니다.&lt;/p&gt;

&lt;p&gt;즉, File’s Owner가 아니라 cell object에 custom class가 연결되는 이유는 File’s Owner를 컨트롤러 객체로 설정하기 위함이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;customview--tableviewcell-&quot;&gt;CustomView = TableViewCell ?&lt;/h2&gt;
&lt;p&gt;custom view를 설정하는 2가지 케이스를 확인해봤습니다. 긴 과정이었음에도 아직 의문점은 해결되지 않았습니다. 왜 거의 모든 블로그는 File’s Owner에 custom class를 설정하는 방법을 사용할까요? 보통 custom view는 컨트롤러 안에 삽입되는 방식으로 많이 사용되고 이는 테이블 뷰와 테이블 뷰 cell의 관계와 같은데 말이죠.&lt;/p&gt;

&lt;p&gt;장점이라면 뷰를 쓸 때마다 owner에 할당할 인스턴스를 고려하지 않아도 되고 CustomView 클래스가 File’s Owner 그 자체이기 때문에 조금 더 깔끔한(?) 인상을 주긴 합니다. 또 2번 방법은 1번 방법과 같은 코드로 실행했을 때 무한루프에 빠지는 오류가 생길 수도 있죠.&lt;/p&gt;

&lt;p&gt;물론 custom view를 스토리보드에서 쓰기 위해서는 다른 방법이 필요합니다. (모듈 어쩌고)
무한루프도 있을 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 잘 생각해보면 xib 자체가 여러 개의 UIView 타입 object를 포함할 수 있게 만들어져 있기도 하고 공식 문서 상에 나와있는 controller object에 부합하는지 개인적으로 의문이 듭니다. xib 하나당 하나의 object를 쓰는 게 거의 정론처럼 굳어져있기는 하지만 글쎄요… UIView 타입 중 하나인 UITableViewCell도 2번 방법으로 생성하는 걸 보면 애플이 생각하는 CustomView 생성 방법의 정답은 무엇인지 알 수 없네요.&lt;/p&gt;

&lt;h2 id=&quot;결론-및-정리&quot;&gt;결론 및 정리&lt;/h2&gt;
&lt;p&gt;CustomView를 만드는 방법을 알아보면서 참 많은 것을 배웠습니다. 미국의 천체물리학자인 닐 디그래스 타이슨이 래리 킹과 했던 인터뷰가 생각납니다. 처음 미적분 책을 봤을 때 이걸 이해나 할 수 있을까 했지만 시도나 해보자 하면서 계속 공부하니 세 달째에 알았답니다. 그에겐 그 순간이  처음엔 무슨 말인지 모르겠더라도, 그냥 시간 내서 배우면 다 된다. 라고 말할 수 있는 “proxy”가 되었다고 했죠. 이 글 하나를 정리하기 위해 썼던 시간의 처음으로 돌아가면 모르는게 너무나도 많았지만 이젠 조금이나마 알 것 같습니다.&lt;/p&gt;

&lt;p&gt;제가 쓴 글이 조금이나마 도움이 되셨기를 바라며 혹시나 내용 중 오류가 있거나 궁금하신 점이 있다면 댓글 남겨주시면 너무나도 감사하겠습니다 :)&lt;/p&gt;

&lt;p&gt;좋은 하루 되세요 🚀&lt;/p&gt;

&lt;p&gt;https://stackoverflow.com/questions/7655560/why-does-a-custom-tableviewcell-not-need-the-file-owner&lt;/p&gt;</content><author><name></name></author><category term="Swift" /><category term="iOS" /><summary type="html">CustomView는 같은 UI를 가지는 View들을 하나의 공통된 View로 묶어 재사용하기 위해 만듭니다. 불필요한 코드의 중복을 줄이고 유지보수를 쉽게 해주기 때문에 저는 되도록 만들어 쓰는 편입니다. CustomView를 만드는 건 이미 많은 블로그에 설명되어 있기 때문에 만드는 방법 보다 CustomView를 만들면서 생긴 호기심을 풀어가는 과정에 집중하여 정리하고자 합니다.</summary></entry><entry><title type="html">JSON과 Codable</title><link href="http://localhost:4000/Swift-JSON-Codable/" rel="alternate" type="text/html" title="JSON과 Codable" /><published>2020-02-20T00:00:00+09:00</published><updated>2020-02-20T00:00:00+09:00</updated><id>http://localhost:4000/Swift-JSON-Codable</id><content type="html" xml:base="http://localhost:4000/Swift-JSON-Codable/">&lt;p&gt;앱 개발을 할 때 JSON 데이터 처리는 기본이면서도 정말 중요합니다. 기존에는 JSON을 주먹구구식으로 핸들링하거나 &lt;code class=&quot;highlighter-rouge&quot;&gt;SwiftyJSON&lt;/code&gt;을 사용했었는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;Swift4&lt;/code&gt;에서 새로 도입된 &lt;code class=&quot;highlighter-rouge&quot;&gt;Codable&lt;/code&gt;을 알게되서 이 프로토콜을 사용하여 JSON 데이터를 더 깔끔하게 처리하는 방법을 정리하고자 합니다.&lt;/p&gt;

&lt;h1 id=&quot;json-예시&quot;&gt;JSON 예시&lt;/h1&gt;
&lt;!-- JSON 예제 코드 --&gt;
&lt;noscript&gt;&lt;pre&gt;{
  &amp;quot;data&amp;quot;: {
    &amp;quot;room&amp;quot;: [
      {
        &amp;quot;name&amp;quot;: &amp;quot;room1&amp;quot;,
        &amp;quot;order&amp;quot;: 1,
        &amp;quot;messages&amp;quot;: [
          {
            &amp;quot;content&amp;quot;: &amp;quot;Mom&amp;quot;,
            &amp;quot;person&amp;quot;: &amp;quot;Tom&amp;quot;,
            &amp;quot;order&amp;quot;: 1
          },
          {
            &amp;quot;content&amp;quot;: &amp;quot;I&amp;#39;m sorry&amp;quot;,
            &amp;quot;person&amp;quot;: &amp;quot;Will&amp;quot;,
            &amp;quot;order&amp;quot;: 2
          },
          {
            &amp;quot;content&amp;quot;: &amp;quot;Thank you&amp;quot;,
            &amp;quot;person&amp;quot;: &amp;quot;Big brother Tom&amp;quot;,
            &amp;quot;order&amp;quot;: 3
          }
        ]
      }
    ]
  }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/cf87c669c296a5392395a7e1eb0f9561.js&quot;&gt; &lt;/script&gt;

&lt;h1 id=&quot;before&quot;&gt;Before&lt;/h1&gt;
&lt;p&gt;위의 예시를 바탕으로 기존에 작성했던 코드는 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;JSONSerialization 객체로 JSON을 Foundation 객체로 변환했습니다. Nested(중첩) JSON이기 때문에 Dictionary로 계속 변환해주었는데 가독성에 문제도 있고, 서버에서 JSON 구조를 변경하게 되면 그에 맞게 코드를 수정하기가 까다롭습니다. 가만히 두고 볼 수 없는 코드입니다.
&lt;!-- 하드하게 디코딩한 코드 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;if let data = jsonString.data(using: .utf8) {
    if let decoded = try? JSONSerialization.jsonObject(with: data, options: []) {
        let dataDic = (decoded as? [String: Any])?[&amp;quot;data&amp;quot;] as? [String: Any] ?? [:]
        let roomArray = dataDic[&amp;quot;room&amp;quot;] as? [[String: Any]] ?? []

        for room in roomArray {
            print(room[&amp;quot;name&amp;quot;])
            print(room[&amp;quot;order&amp;quot;])
            
            let messages = room[&amp;quot;messages&amp;quot;] as? [[String: Any]] ?? []
            
            for msg in messages {
                print(msg[&amp;quot;content&amp;quot;])
                print(msg[&amp;quot;person&amp;quot;])
                print(msg[&amp;quot;order&amp;quot;])
            }
        }
    }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/550a3febcce5421f7020a9ef5185c389.js&quot;&gt; &lt;/script&gt;

&lt;h1 id=&quot;codable&quot;&gt;Codable&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Codable&lt;/code&gt;을 적용하기 전에 이 프로토콜이 어떤 역할을 하는지 알아야 할 필요가 있습니다. Codable은 Decodable과 Encodable을 포함하는 프로토콜이라고 &lt;a href=&quot;https://developer.apple.com/documentation/swift/codable&quot; target=&quot;blank&quot;&gt;애플 공식 문서&lt;/a&gt;에 나와있네요. &lt;a href=&quot;https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types&quot; target=&quot;blank&quot;&gt;Encoding and Decoding Custom Types&lt;/a&gt;에서 Swift는 데이터를 인코딩하고 디코딩하는 표준화 된 접근법을 정의하고 있으며, 이 접근법은 Decodable과 Encodable 프로토콜을 적용한 방법이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types&quot; target=&quot;blank&quot;&gt;Encoding and Decoding Custom Types&lt;/a&gt;는 공식 문서로서 커스텀 타입을 인코딩, 디코딩 하는 방법이 잘 설명되어 있으니 꼭 참고하시길 바랍니다.&lt;/p&gt;

&lt;h1 id=&quot;codingkey&quot;&gt;CodingKey&lt;/h1&gt;
&lt;p&gt;Codable을 적용하게 되면 이 &lt;a href=&quot;https://developer.apple.com/documentation/swift/codingkey&quot; target=&quot;blank&quot;&gt;CodingKey&lt;/a&gt;라는 것도 필요합니다. CodingKey는 인코딩과 디코딩을 위한 키로 쓰이는 &lt;strong&gt;타입&lt;/strong&gt;입니다. 그럼 이제 JSON 예시에 맞게 코드를 바꿔보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;struct-with-codable&quot;&gt;Struct with Codable&lt;/h1&gt;
&lt;p&gt;예시로 든 JSON에는 room key와 messages key안에 배열로 된 데이터가 있습니다. 따라서 &lt;strong&gt;Result &amp;gt; Room &amp;gt; Message&lt;/strong&gt; 집합 관계로 정의된 구조체에 Codable을 적용했습니다. 또한, CodingKey 프로토콜을 상속받은 CodingKeys의 case가 json 데이터의 key로 매핑되는 것을 알 수 있습니다. 예를 들어, &lt;strong&gt;Result의 rooms&lt;/strong&gt;에는 &lt;strong&gt;room&lt;/strong&gt; key에 해당하는 value가 매핑됩니다.
&lt;!-- Codable 적용한 구조체 코드 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;struct Result: Codable {
    var success: Bool?
    var reason: String?
    var rooms: [Room]?
    
    enum CodingKeys: String, CodingKey {
        case success, reason, rooms = &amp;quot;room&amp;quot;
        case data = &amp;quot;data&amp;quot;
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let data = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .data)
        
        success = try container.decode(Bool.self, forKey: .success)
        reason = try container.decode(String.self, forKey: .reason)
        rooms = try data.decode([Room].self, forKey: .rooms)
    }
}

struct Room: Codable {
    var name: String?
    var order: Int?
    var messages: [Message]?
    
    enum CodingKeys: String, CodingKey {
        case name, order, messages
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        name = try container.decode(String.self, forKey: .name)
        order = try container.decode(Int.self, forKey: .order)
        messages = try container.decode([Message].self, forKey: .messages)
    }
}

struct Message : Codable {
    var content: String?
    var person: String?
    var order: Int?
    
    enum CodingKeys: String, CodingKey {
        case content, person, order
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        content = try container.decode(String.self, forKey: .content)
        person = try container.decode(String.self, forKey: .person)
        order = try container.decode(Int.self, forKey: .order)
    }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/e665070d5d6d6b873446e217e2ea8072.js&quot;&gt; &lt;/script&gt;

&lt;h1 id=&quot;after&quot;&gt;After&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;try? JSONDecoder().decode(Result.self, from: data)&lt;/code&gt; 코드 한 줄로 Result, Room, Message 데이터까지 깔끔하게 처리할 수 있게 되었습니다.
표준 라이브러리 설명과 함께 코드를 보면서 어떻게 동작하는지 좀 더 자세하게 살펴보겠습니다.
&lt;!-- Codable이 적용된 구조체로 디코딩하는 예제 코드 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;let data = jsonString.data(using: .utf8) ?? Data()
if let result = try? JSONDecoder().decode(Result.self, from: data) {
    print(&amp;quot;success : \(result.success ?? false)&amp;quot;)
    print(&amp;quot;reason : \(result.reason ?? &amp;quot;&amp;quot;)\n&amp;quot;)
    
    result.rooms?.forEach{ room in
        print(&amp;quot;  name : \(room.name ?? &amp;quot;&amp;quot;)&amp;quot;)
        print(&amp;quot;  order : \(room.order ?? 0)\n&amp;quot;)
        
        room.messages?.forEach { message in
            print(&amp;quot;    content : \(message.content ?? &amp;quot;&amp;quot;)&amp;quot;)
            print(&amp;quot;    person : \(message.person ?? &amp;quot;&amp;quot;)&amp;quot;)
            print(&amp;quot;    order : \(message.order ?? 0)\n&amp;quot;)
        }
    }
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/5a0e1026e5313142c2db2a216bea93d3.js&quot;&gt; &lt;/script&gt;

&lt;h3 id=&quot;1-json-데이터를-특정-타입으로-decoding&quot;&gt;1. JSON 데이터를 특정 타입으로 Decoding&lt;/h3&gt;
&lt;p&gt;decode 메서드는 디코딩 될 data로부터 Result 타입의 value를 만들어줍니다.
&lt;!-- 표준 라이브러리 코드 1 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;if let result = try? JSONDecoder().decode(Result.self, from: data)

/// decode 표준 라이브러리

/// Decodes a top-level value of the given type from the given JSON representation.
///
/// - parameter type: The type of the value to decode.
/// - parameter data: The data to decode from.
/// - returns: A value of the requested type.
/// - throws: `DecodingError.dataCorrupted` if values requested from the payload are corrupted, or if the given data is not valid JSON.
/// - throws: An error if any value throws an error during decoding.
open func decode&amp;lt;T&amp;gt;(_ type: T.Type, from data: Data) throws -&amp;gt; T where T : Decodable&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/3f1252e502a98ce31801600d325a9d32.js&quot;&gt; &lt;/script&gt;

&lt;h3 id=&quot;2-데이터로부터-container-생성&quot;&gt;2. 데이터로부터 container 생성&lt;/h3&gt;
&lt;p&gt;1번 코드가 Result를 초기화하는 init 코드를 실행하고 decoder에 담겨있던 data로부터 container를 생성해줍니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;CodingKeys.self&lt;/code&gt; 타입이 data의 key와 매핑이 되지 않는다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;DecodingError.typeMismatch&lt;/code&gt; 에러를 던지겠네요.
&lt;!-- 표준 라이브러리 코드 2 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;let container = try decoder.container(keyedBy: CodingKeys.self)

/// container 

/// Returns the data stored in this decoder as represented in a container
/// keyed by the given key type.
///
/// - parameter type: The key type to use for the container.
/// - returns: A keyed decoding container view into this decoder.
/// - throws: `DecodingError.typeMismatch` if the encountered stored value is
///   not a keyed container.
func container&amp;lt;Key&amp;gt;(keyedBy type: Key.Type) throws -&amp;gt; KeyedDecodingContainer&amp;lt;Key&amp;gt; where Key : CodingKey&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/c1e77fd8d79dc5816d67cd85b08ea030.js&quot;&gt; &lt;/script&gt;

&lt;h3 id=&quot;3-container에서-nestedcontainer-생성&quot;&gt;3. container에서 nestedContainer 생성&lt;/h3&gt;
&lt;p&gt;Nested JSON이기 때문에 해당 키에 대한 sub container(=nestedContainer)를 생성해줍니다.
&lt;!-- 표준 라이브러리 코드 3 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;let data = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .data)

///  nestedContainer 표준 라이브러리

/// Returns the data stored for the given key as represented in a container
/// keyed by the given key type.
///
/// - parameter type: The key type to use for the container.
/// - parameter key: The key that the nested container is associated with.
/// - returns: A keyed decoding container view into `self`.
/// - throws: `DecodingError.typeMismatch` if the encountered stored value is
///   not a keyed container.
public func nestedContainer&amp;lt;NestedKey&amp;gt;(keyedBy type: NestedKey.Type, forKey key: KeyedDecodingContainer&amp;lt;K&amp;gt;.Key) throws -&amp;gt; KeyedDecodingContainer&amp;lt;NestedKey&amp;gt; where NestedKey : CodingKey&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/0c1a401def1d28b496f0bf3947560525.js&quot;&gt; &lt;/script&gt;

&lt;h3 id=&quot;4-nestedcontainer에서-room-데이터-디코딩&quot;&gt;4. nestedContainer에서 [Room] 데이터 디코딩&lt;/h3&gt;
&lt;p&gt;Room 타입도 Codable을 상속받은 구조체이기 때문에 이 과정에서 Room도 디코딩이 진행되고 마찬가지로 Message도 디코딩이 이루어집니다.
&lt;!-- 표준 라이브러리 코드 4 --&gt;&lt;/p&gt;
&lt;noscript&gt;&lt;pre&gt;rooms = try data.decode([Room].self, forKey: .rooms)

/// decode 표준 

/// Decodes a value of the given type for the given key.
///
/// - parameter type: The type of value to decode.
/// - parameter key: The key that the decoded value is associated with.
/// - returns: A value of the requested type, if present for the given key
///   and convertible to the requested type.
/// - throws: `DecodingError.typeMismatch` if the encountered encoded value
///   is not convertible to the requested type.
/// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
///   for the given key.
/// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
///   the given key.
public func decode&amp;lt;T&amp;gt;(_ type: T.Type, forKey key: KeyedDecodingContainer&amp;lt;K&amp;gt;.Key) throws -&amp;gt; T where T : Decodable&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/RoKang/a56af6bb733cf19bebbbf177f460d831.js&quot;&gt; &lt;/script&gt;

&lt;h1 id=&quot;tip&quot;&gt;Tip&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;바닐라 Codable도 JSONSerialization을 사용한 방법에 비해서 훨씬 편해졌지만, &lt;a href=&quot;https://github.com/JohnSundell/Codextended&quot; target=&quot;blank&quot;&gt;Codextended&lt;/a&gt;는 Codable 코드를 더 깔끔하게 만들어줍니다. Codable에 익숙해진다면 고려해 볼 만한 옵션인 것 같습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;날짜 JSON 데이터를 Date 타입으로 포맷팅하는건 생각보다 귀찮은 일 입니다. 그래서 Codable에는 어떤 날짜 데이터가 &lt;strong&gt;특정 포맷에 맞다면 자동으로 Date 인스턴스로 디코딩 해주는 strategy(전략)&lt;/strong&gt;이 포함되어 있습니다.&lt;/p&gt;

    &lt;p&gt;formatter 인스턴스를 만들어서 원하는 포맷의 데이터를 Date로 변환할 수도 있고 iso8601 옵션처럼 표준화 된 포맷을 적용할 수도 있습니다. 저는 &lt;strong&gt;formatted&lt;/strong&gt;나 &lt;strong&gt;iso8601&lt;/strong&gt; 옵션을 많이 활용하게 될 것 같습니다.
&lt;!-- JSONDecoder().dateDecodingStrategy 예제 코드 1 --&gt;&lt;noscript&gt;&amp;lt;pre&amp;gt;let formatter = DateFormatter()
formatter.dateFormat = &quot;yyyy.MM.dd&quot;
JSONDecoder().dateDecodingStrategy = .formatted(formatter)
JSONDecoder().dateDecodingStrategy = .iso8601
JSONDecoder().dateDecodingStrategy = .millisecondsSince1970
JSONDecoder().dateDecodingStrategy = .secondsSince1970&amp;lt;/pre&amp;gt;&lt;/noscript&gt;&lt;script src=&quot;https://gist.github.com/RoKang/fa262e9d404d05cf4c7938978fbf7043.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;
&lt;p&gt;정리한 내용이 디코딩만을 다루고 있지만, 인코딩은 JSONEncoder 클래스를 활용한 반대의 과정이기 때문에 디코딩을 잘 알고 있다면 어렵지 않을 것 같습니다.&lt;/p&gt;

&lt;p&gt;내용 중 오류가 있거나 궁금하신 점이 있다면 댓글 남겨주시면 감사하겠습니다 :)&lt;/p&gt;</content><author><name></name></author><category term="Swift" /><category term="iOS" /><category term="JSON" /><category term="Codable" /><summary type="html">앱 개발을 할 때 JSON 데이터 처리는 기본이면서도 정말 중요합니다. 기존에는 JSON을 주먹구구식으로 핸들링하거나 SwiftyJSON을 사용했었는데, Swift4에서 새로 도입된 Codable을 알게되서 이 프로토콜을 사용하여 JSON 데이터를 더 깔끔하게 처리하는 방법을 정리하고자 합니다.</summary></entry></feed>